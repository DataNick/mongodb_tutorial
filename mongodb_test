use wands #creates a db called wands

db.wands.find() #finds all items in wands database

db.wands.insert(
  { name: "Potion N. 09",
    author: "Lazarus Nimbleton"},
  { name: "Sleepy Time",
    author: "Roland Beschel"}
) #inserts objects into database

db.wands.remove({name: "Love"})

#update fields for first matching document

db.wands.update(
query parameter,
update parameter (begin with a $)
)

db.wands.update(
{name: "Love"},
{"$set": {price: 9.99}},
{"multi": false (by default)})

{"$inc": {"count": 1}}
{upsert: true}

#to perform multiple updates, include third parameter (options parameter)

#will find document with name of love and replace entire document with price
db.wands.update(
{name: "Love"},
{price: 9.99})


#Update operators

$unset operator

db.potions.update(
{} #selects all documents in potions collection,
{"$unset": "color": "" #remove colour field},
{"multi": true}
)

#rename fields

Use the $rename update operator
db.potions.update(
{} #selects all documents in potions collection,
{"$rename": {"score" : "grade" #rename field to grade}},
{"multi": true}
)

#if a field has array values, there is a way to select and change values within arrays
#use dot notation and update them individually
#specify field name and the index of item that is to be modified

db.potions.update(
{"name": "Shrinking"},
{"$set": {"ingredients.1" : 42 }},
{"multi": true}
)

#but when we don't know the index of the value, then we use the positional operator
db.potions.update(
{"ingredients": "secret" #query for value we want to change},
{"$set": {"ingredients.$" : 42 }},
{"multi": true}
)


#updating embedded values

ratings: {
  flavour: 2,
  scent: 4,
  strength: 5
}

db.potions.update(
  {"name": "Shrinking"},
  {"$set": {"ratings.strength" : 5}}
  )

#Other update operators

$max --> allows for the updating of a value only if it is greater than current value or inserts if empty
$min --> allows to update if the new value only if it is lesser than current value or inserts if empty
$mul --> multiplies current field value by a specified value. If empty, inserts 0.

Arrays are common ways to store data
$pop --> remove first or last value in array
$push --> add values to end of array
$pull --> removes all instances of a specified value from an array
$addToSet --> only adds value if not already present

db.potions.update(
  {"name": "Shrinking"},
  {"$mul": {"ratings.strength" : 10}} #this will set the strength to 50
  )

#query operators and customizing results
#filtering --> passing multiple queries to find method

db.potions.find(
  {
  "vendor": "Kettlecooked",
  "ratings.strength": 5
  }
)

#query based on conditions i.e. price less than 20
comparison query operators
$gt
$lt
$gte
$lte
$ne
db.potions.find(
  {"price": {"$lt": 20}}
)

db.potions.find(
  {"price": {"$gt": 10, "$lt": 20}}
)

$elemMatch
ensure at least 1 element in an array matches all criteria
db.potions.find(
  {"price": {"$elemMatch": {"$gt": 10, "$lt": 20}}}
)

arrays act differently with range criteria than normal values
Running a query on an array -->
each value in array is checked individually. If at least 1 array value is true for each criteria, the entire document matches.
The document will not match if only 1 criteria is met.
Whenever dealing with ranges in an array, always use an array query operator

db.wands.find(
  {"maker": {"$ne": "Foxmond"},
  "level_required": {"$lte": 75},
  "price": {"$lt": 50},
  "lengths": {"$elemMatch": {"$gte": 3, "$lte": 4}}
  }
)

#projections to select items based on conditions and only return certain fields
db.potions.find(
  {"grade": {"$gte": 10}},
  {"vendor": true, "name": true}
)

#return all fields except those set to false
db.potions.find(
  {"grade": {"$gte": 10}},
  {"vendor": false, "name": false}
)

db.potions.find(
  {}, #selects all documents in potions collection
  {"name": true}
)

#select all records by using {}

#when running the find method, objects returned are cursor objects
#run methods on cursor objects
db.potions.find().count()
db.potions.find().sort({"price": 1}) #1 for ascending or -1 for descending
db.potions.find().limit()
db.potions.find().skip().limit() #will need to be changed for each page

db.wands.find(
  {},
  {"name": true, "powers": true, "_id": false}
).sort({"price": 1}) #sorting by price in ascending order


// How to best model data
i.e. USERS and their favourite POTIONS

#insertion through an embebbed document
data integrity - ensuring data is consistent
instead of embedding vendor information directly into potions document
create a vendors collection and reference vendor document in each potion document.
A step in normalizing data.
Document references are manual - mongodb only sees field value pairs.
To get vendor document, run query on potion to get vendor_id then run query on vendor with id equal to vendor_id to get document in vendor collection

Embedding vs Referencing
Embedding allows for one query action
Atomic writes -> for updating, for example, multiple fields, either all changes would occur on nothing would be updated. Ensures document write completely happens or cancels everything

Referencing requires multiple queries
Reference documents are independent documents
Ideal for data that occasionally is used together but sometimes stands alone.
Only need to update vendor information in one place
Reduce inconsistencies
Cannot atomically write to multiple documents
In RDM, this is called a transaction, which MongoDB does not support by default
If updating a new potion from a new vendor, if updating the potion is written but the vendor update hits an error, no rollback would occur
There would be a potion document where the vendor is non-existent. When trying to use vendor_id, an error would occur. However, in the potion document, the reference (vendor_id) would exist on a non-existent vendor --> PROBLEMS





























